<!--

	TO DO:
	+ why does obj receed to point off to the side?
		- is it bc document.innerWidth? should be div?
	+ how to load model into variable when using callback 
	+ is there a way to detect bandwidth and not show model?

	+ add line between camera and obj center
-->

<!DOCTYPE html>
<html>
<head>
	<title>++ MODEL TEST ++</title>
	<meta charset="UTF-8">
	
	<link href="stylesheet.css" rel="stylesheet" type="text/css">
	<link href="model-styles.css" rel="stylesheet" type="text/css">
	<link href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">

	<script src="js/three.min.js"></script>
	<script src="js/MTLLoader.js"></script>
	<script src="js/OBJMTLLoader.js"></script>
	<script src="js/Detector.js"></script>
	<script src="js/stats.min.js"></script>
	<script src="js/TrackballControls.js"></script>

	<script>
		var modelName = '080';
	</script>

	<style>
		#model {
			width: 80%;
			margin: 0 auto;	
			overflow: hidden;	/* required to cut off R side */
		}
	</style>

</head>

<body>

	<div id="wrapper">

		<div id="model">
			
			<!-- loading animation until ready -->
			<div id="loadingAnimation">
				<i class="icon-spinner icon-spin icon-large"></i>
				<p>Loading model, please be patient!</p>
			</div>

		</div> <!-- end model -->

		<p>This is a test of the model.</p>

	</div> <!-- end wrapper -->

	<!-- 3D magic -->
	<script>

		var rotSpeed = 0.3;

		var model;
		var container, stats;
		var camera, scene, renderer;
		var mouseX = 0, mouseY = 0;
		var windowHalfX = window.innerWidth / 2;
		var windowHalfY = window.innerHeight / 2;
		var verticalScaling = 0.8;	// for height control of div

		init();
		animate();

		function init() {
			container = document.getElementById('model');

			// scene and camera
			scene = new THREE.Scene();

			camera = new THREE.PerspectiveCamera(45, container.offsetWidth / (container.offsetHeight * verticalScaling), 1, 1000);
			//camera = new THREE.PerspectiveCamera(45, window.innerWidth / (window.innerHeight * verticalScaling), 1, 1000);

			//camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 100000);	// 0.1/100k = almost no clipping
			
			// camera.position.set(300,0,0);
			// camera.up = new THREE.Vector3(0,0,1);
			// camera.lookAt(new THREE.Vector3(0,0,0));
			
			//camera.position.z = 100;
			
			scene.add(camera);

			// controls
			controls = new THREE.TrackballControls(camera, container);	// controls only in div!
			controls.rotateSpeed = 1.0;
			controls.zoomSpeed = 1.2;
			controls.panSpeed = 0.8;
			controls.noZoom = false;
			controls.noPan = false;
			controls.staticMoving = true;
			controls.dynamicDampingFactor = 0.3;
			controls.keys = [ 65, 83, 68 ];
			controls.addEventListener('change', render);

			// lights
			var ambient = new THREE.AmbientLight(0x444444);
			scene.add(ambient);

			var directionalLight = new THREE.DirectionalLight(0xffeedd);
			directionalLight.position.set(0, 0, 1).normalize();
			scene.add(directionalLight);
			
			// model
			var loader = new THREE.OBJMTLLoader();
			loader.load('models/' + modelName + '.obj', 'models/' + modelName + '.mtl', function(model) {
				
				// move camera to so object fills the screen
				// (or divide by aspect ratio, via: http://stackoverflow.com/a/16940705/1167783)
				var bs = model.children[0].geometry.boundingSphere;				
				camera.position.z = (bs.radius * 10);

				scene.add(model);
			});


			// renderer
			renderer = new THREE.WebGLRenderer();
			renderer.setSize(window.innerWidth, window.innerHeight * verticalScaling);		// height to 80%
			container.appendChild(renderer.domElement);

			// remove loading animation
			var loadingAnimation = document.getElementById('loadingAnimation');
			loadingAnimation.parentNode.removeChild(loadingAnimation);

			// handle mouse movement and resize
			document.addEventListener('mousemove', onDocumentMouseMove, false);
			window.addEventListener('resize', onWindowResize, false);
		}

		function onWindowResize() {
			windowHalfX = window.innerWidth / 2;
			windowHalfY = window.innerHeight / 2;

			camera.aspect = container.offsetWidth / container.offsetHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight * verticalScaling);		// height to 80%
		}

		function onDocumentMouseMove(event) {
			mouseX = (event.clientX - windowHalfX) / 2;
			mouseY = (event.clientY - windowHalfY) / 2;
		}

		function animate() {
			requestAnimationFrame(animate);
			controls.update();
			render();
		}

		function render() {
			camera.position.x += rotSpeed;
			camera.position.y += rotSpeed;
			console.log(camera.position.x + ', ' + camera.position.y);
			renderer.render(scene, camera);
		}
	</script>

</body>
</html>